* Overview

This configuration provides a unified code folding interface for Emacs that combines:
- Built-in hideshow functionality
- Modern tree-sitter based folding with treesit-fold
- LSP server folding range support
- Visual indicators and state persistence
- Doom modeline integration

** Features
- Unified keybindings across different folding methods
- Visual fold indicators with line counts
- Gruvbox dark theme integration
- Persistent folding states across sessions
- Doom modeline folding status display

* Core Folding Packages

** Hideshow (Built-in)
Emacs' built-in code folding system with enhanced overlay display.

#+begin_src emacs-lisp
;;; Enhanced Code Folding Configuration for Emacs
;; Provides unified folding interface with hideshow, treesit-fold, and LSP integration

(use-package hideshow
  :ensure nil
  :diminish hs-minor-mode
  :hook (prog-mode . hs-minor-mode)
  :custom
  (hs-hide-comments-when-hiding-all t)
  (hs-allow-nesting t)
  
  :config
  ;; Gruvbox dark theme faces
  (custom-set-faces
   '(hs-face ((t (:background "#504945" :foreground "#a89984" 
                  :box (:line-width 1 :color "#665c54")))))
   '(hs-fringe-face ((t (:foreground "#fb4934")))))
  
  ;; Enhanced overlay display with line counts
  (defun hs-display-code-line-counts (ov)
    "Display line counts for folded regions."
    (when (eq 'code (overlay-get ov 'hs))
      (let* ((nlines (count-lines (overlay-start ov) (overlay-end ov)))
             (info (format " ... (%d lines)" nlines)))
        (overlay-put ov 'display (propertize info 'face 'hs-face)))))
  
  (setq hs-set-up-overlay 'hs-display-code-line-counts)
  
  :bind (("C-c h t" . hs-toggle-hiding)
         ("C-c h h" . hs-hide-block)
         ("C-c h s" . hs-show-block)
         ("C-c h H" . hs-hide-all)
         ("C-c h S" . hs-show-all)))
#+end_src

** Treesit-fold Integration
Modern tree-sitter based folding with enhanced summaries.

#+begin_src emacs-lisp
(use-package treesit-fold
  :ensure t
  :after treesit
  :hook ((c-ts-mode c++-ts-mode python-ts-mode json-ts-mode 
          bash-ts-mode typescript-ts-mode) . treesit-fold-mode)
  :custom
  (treesit-fold-summary-show t)
  (treesit-fold-replacement "...")
  
  :config
  ;; Gruvbox dark theme faces
  (custom-set-faces
   '(treesit-fold-replacement-face 
     ((t (:foreground "#a89984" :background "#504945" 
          :box (:line-width 1 :color "#665c54") :weight bold))))
   '(treesit-fold-fringe-face ((t (:foreground "#fb4934")))))
  
  ;; Enhanced summary with line counts
  (defun treesit-fold-summary-with-count (range)
    "Show summary with line count for folded region."
    (let* ((start (car range))
           (end (cdr range))
           (lines (count-lines start end))
           (summary (treesit-fold--get-summary start end)))
      (format "%s (%d lines)" (or summary "...") lines)))
  
  (setq treesit-fold-summary-function #'treesit-fold-summary-with-count)
  
  :bind (("C-c f t" . treesit-fold-toggle)
         ("C-c f h" . treesit-fold-close)
         ("C-c f s" . treesit-fold-open)
         ("C-c f H" . treesit-fold-close-all)
         ("C-c f S" . treesit-fold-open-all)))
#+end_src

* LSP Integration

** LSP Folding Range Support
Integration with Language Server Protocol folding ranges via eglot.

#+begin_src emacs-lisp
(defun lsp-folding-range-support-p ()
  "Check if current LSP server supports folding ranges."
  (and (bound-and-true-p eglot--managed-mode)
       (eglot-current-server)
       (eglot--server-capable :foldingRangeProvider)))

(defun lsp-get-folding-ranges ()
  "Get folding ranges from LSP server."
  (when (lsp-folding-range-support-p)
    (condition-case nil
        (jsonrpc-request (eglot-current-server)
                         :textDocument/foldingRange
                         (list :textDocument (eglot--TextDocumentIdentifier)))
      (error nil))))

(defun lsp-apply-folding-ranges ()
  "Apply folding ranges from LSP server using hideshow."
  (interactive)
  (when-let ((ranges (lsp-get-folding-ranges)))
    (save-excursion
      (dolist (range ranges)
        (let* ((start-line (1+ (gethash "startLine" range)))
               (end-line (1+ (gethash "endLine" range))))
          (goto-char (point-min))
          (forward-line (1- start-line))
          (let ((start-pos (point)))
            (forward-line (- end-line start-line))
            (when (> (count-lines start-pos (point)) 1)
              (hs-hide-block-at-point start-pos))))))))

(defun hs-hide-block-at-point (pos)
  "Hide block at specific position."
  (save-excursion
    (goto-char pos)
    (when (hs-find-block-beginning)
      (hs-hide-block))))

;; Add LSP folding keybinding when eglot is active
(with-eval-after-load 'eglot
  (add-hook 'eglot-managed-mode-hook
            (lambda ()
              (when (lsp-folding-range-support-p)
                (local-set-key (kbd "C-c e f") #'lsp-apply-folding-ranges)))))
#+end_src

* Visual Enhancements

** Fringe Indicators
Custom fringe bitmaps for fold indicators with Gruvbox theming.

#+begin_src emacs-lisp
(use-package fringe
  :ensure nil
  :config
  ;; Gruvbox dark theme fringe
  (custom-set-faces
   '(fringe ((t (:background "#282828" :foreground "#a89984")))))
  
  ;; Enhanced fold indicators
  (when (fboundp 'define-fringe-bitmap)
    (define-fringe-bitmap 'fold-indicator
      [#b11111111
       #b10000001
       #b10000001
       #b10000001
       #b10000001
       #b10000001
       #b10000001
       #b11111111]
      nil 8 'center)
    
    (define-fringe-bitmap 'unfold-indicator
      [#b11111111
       #b10000001
       #b10111101
       #b10111101
       #b10111101
       #b10111101
       #b10000001
       #b11111111]
      nil 8 'center))
  
  ;; Set fringe width
  (fringe-mode '(8 . 8)))
#+end_src

* Unified Interface

** Smart Folding Functions
Unified commands that automatically choose the best folding method available.

#+begin_src emacs-lisp
(defun unified-fold-toggle ()
  "Toggle folding using the best available method."
  (interactive)
  (cond
   ;; Prefer treesit-fold for tree-sitter modes
   ((and (bound-and-true-p treesit-fold-mode)
         (fboundp 'treesit-fold-toggle))
    (treesit-fold-toggle))
   ;; Fall back to hideshow
   ((bound-and-true-p hs-minor-mode)
    (hs-toggle-hiding))
   (t (message "No folding available"))))

(defun unified-fold-hide-all ()
  "Hide all folds using the best available method."
  (interactive)
  (cond
   ((and (bound-and-true-p treesit-fold-mode)
         (fboundp 'treesit-fold-close-all))
    (treesit-fold-close-all))
   ((bound-and-true-p hs-minor-mode)
    (hs-hide-all))
   (t (message "No folding available"))))

(defun unified-fold-show-all ()
  "Show all folds using the best available method."
  (interactive)
  (cond
   ((and (bound-and-true-p treesit-fold-mode)
         (fboundp 'treesit-fold-open-all))
    (treesit-fold-open-all))
   ((bound-and-true-p hs-minor-mode)
    (hs-show-all))
   (t (message "No folding available"))))

;; Global unified keybindings
(global-set-key (kbd "C-c TAB") #'unified-fold-toggle)
(global-set-key (kbd "C-c C-h") #'unified-fold-hide-all)
(global-set-key (kbd "C-c C-s") #'unified-fold-show-all)
#+end_src

* State Management

** Folding State Tracking
Real-time tracking of folding states for modeline display.

#+begin_src emacs-lisp
(defvar-local folding-state-cache nil
  "Cache for folding state to avoid expensive calculations.")

(defvar folding-state-update-timer nil
  "Timer for updating folding state.")

(defun folding-count-folds ()
  "Count total and active folds in current buffer."
  (let ((total-folds 0)
        (active-folds 0))
    ;; Count hideshow folds
    (when (bound-and-true-p hs-minor-mode)
      (save-excursion
        (goto-char (point-min))
        (while (not (eobp))
          (when (hs-overlay-at (point))
            (setq total-folds (1+ total-folds))
            (when (overlay-get (car (hs-overlay-at (point))) 'invisible)
              (setq active-folds (1+ active-folds))))
          (forward-line 1))))
    
    ;; Count treesit-fold folds
    (when (bound-and-true-p treesit-fold-mode)
      (dolist (ov (overlays-in (point-min) (point-max)))
        (when (overlay-get ov 'treesit-fold)
          (setq total-folds (1+ total-folds))
          (when (overlay-get ov 'invisible)
            (setq active-folds (1+ active-folds))))))
    
    (cons active-folds total-folds)))

(defun folding-update-state-cache ()
  "Update folding state cache."
  (when (or (bound-and-true-p hs-minor-mode)
            (bound-and-true-p treesit-fold-mode))
    (setq folding-state-cache (folding-count-folds))))

(defun folding-schedule-update ()
  "Schedule folding state update."
  (when folding-state-update-timer
    (cancel-timer folding-state-update-timer))
  (setq folding-state-update-timer
        (run-with-idle-timer 0.5 nil #'folding-update-state-cache)))

;; Update cache on fold changes
(advice-add 'hs-toggle-hiding :after (lambda (&rest _) (folding-schedule-update)))
(advice-add 'hs-hide-all :after (lambda (&rest _) (folding-schedule-update)))
(advice-add 'hs-show-all :after (lambda (&rest _) (folding-schedule-update)))

(when (fboundp 'treesit-fold-toggle)
  (advice-add 'treesit-fold-toggle :after (lambda (&rest _) (folding-schedule-update)))
  (advice-add 'treesit-fold-close-all :after (lambda (&rest _) (folding-schedule-update)))
  (advice-add 'treesit-fold-open-all :after (lambda (&rest _) (folding-schedule-update))))
#+end_src

* Doom Modeline Integration

** Modeline Segment Definition
Custom doom-modeline segment to display folding status.

#+begin_src emacs-lisp
(with-eval-after-load 'doom-modeline
  ;; Define folding segment
  (doom-modeline-def-segment folding
    "Folding state indicator for doom-modeline."
    (when (and (or (bound-and-true-p hs-minor-mode)
                   (bound-and-true-p treesit-fold-mode))
               folding-state-cache)
      (let* ((active (car folding-state-cache))
             (total (cdr folding-state-cache))
             (icon (if (> active 0) "▼" "▶"))
             (face (if (> active 0) 'doom-modeline-info 'doom-modeline-buffer-minor-mode)))
        (concat
         (doom-modeline-spc)
         (propertize icon 'face face)
         (when (> total 0)
           (propertize (format "%d/%d" active total) 'face face))))))

  ;; Custom doom modeline with folding (fixed checker segment)
  (doom-modeline-def-modeline 'folding-modeline
    '(bar workspace-name window-number modals matches follow buffer-info 
      remote-host buffer-position word-count parrot selection-info)
    '(compilation objed-state misc-info persp-name battery grip irc mu4e gnus 
      github debug repl lsp minor-modes folding input-method indent-info 
      buffer-encoding major-mode process vcs time))

  ;; Function to toggle folding modeline
  (defun toggle-folding-modeline ()
    "Toggle between default and folding-enabled doom modeline."
    (interactive)
    (if (eq doom-modeline-current-modeline 'folding-modeline)
        (doom-modeline-set-modeline 'main)
      (doom-modeline-set-modeline 'folding-modeline))
    (force-mode-line-update))

  ;; Auto-enable folding modeline in programming modes
  (defun maybe-enable-folding-modeline ()
    "Enable folding modeline in programming buffers."
    (when (and (derived-mode-p 'prog-mode)
               (or (bound-and-true-p hs-minor-mode)
                   (bound-and-true-p treesit-fold-mode)))
      (doom-modeline-set-modeline 'folding-modeline)
      (folding-update-state-cache)))

  (add-hook 'prog-mode-hook #'maybe-enable-folding-modeline)
  (add-hook 'hs-minor-mode-hook #'maybe-enable-folding-modeline)
  (add-hook 'treesit-fold-mode-hook #'maybe-enable-folding-modeline)

  ;; Keybinding to toggle folding modeline
  (global-set-key (kbd "C-c m f") #'toggle-folding-modeline))
#+end_src

* State Persistence

** Save and Restore Folding States
Persistent folding states across Emacs sessions.

#+begin_src emacs-lisp
(defvar folding-save-file (expand-file-name "folding-states.el" user-emacs-directory)
  "File to save folding states.")

(defun folding-save-state ()
  "Save current buffer's folding state."
  (interactive)
  (when (and buffer-file-name
             (or (bound-and-true-p hs-minor-mode)
                 (bound-and-true-p treesit-fold-mode)))
    (let ((states '())
          (file buffer-file-name))
      ;; Collect hideshow states
      (when (bound-and-true-p hs-minor-mode)
        (save-excursion
          (goto-char (point-min))
          (while (not (eobp))
            (when-let ((ov (car (hs-overlay-at (point)))))
              (when (overlay-get ov 'invisible)
                (push (list 'hs (overlay-start ov) (overlay-end ov)) states)))
            (forward-line 1))))
      
      ;; Collect treesit-fold states
      (when (bound-and-true-p treesit-fold-mode)
        (dolist (ov (overlays-in (point-min) (point-max)))
          (when (and (overlay-get ov 'treesit-fold)
                     (overlay-get ov 'invisible))
            (push (list 'treesit (overlay-start ov) (overlay-end ov)) states))))
      
      ;; Save to file
      (when states
        (let ((all-states (if (file-exists-p folding-save-file)
                              (with-temp-buffer
                                (insert-file-contents folding-save-file)
                                (condition-case nil
                                    (read (current-buffer))
                                  (error '())))
                            '())))
          (setf (alist-get file all-states nil nil #'string=) states)
          (with-temp-file folding-save-file
            (prin1 all-states (current-buffer))))))))

(defun folding-restore-state ()
  "Restore folding state for current buffer."
  (interactive)
  (when (and buffer-file-name
             (file-exists-p folding-save-file))
    (condition-case nil
        (let* ((all-states (with-temp-buffer
                             (insert-file-contents folding-save-file)
                             (read (current-buffer))))
               (states (alist-get buffer-file-name all-states nil nil #'string=)))
          (dolist (state states)
            (let ((type (car state))
                  (start (cadr state))
                  (end (caddr state)))
              (when (and (>= start (point-min)) (<= end (point-max)))
                (cond
                 ((eq type 'hs)
                  (when (bound-and-true-p hs-minor-mode)
                    (save-excursion
                      (goto-char start)
                      (hs-hide-block))))
                 ((eq type 'treesit)
                  (when (bound-and-true-p treesit-fold-mode)
                    (save-excursion
                      (goto-char start)
                      (treesit-fold-close)))))))))
      (error (message "Failed to restore folding state")))))

;; Auto-save/restore hooks
(add-hook 'kill-buffer-hook #'folding-save-state)
(add-hook 'find-file-hook 
          (lambda () 
            (run-with-idle-timer 1 nil #'folding-restore-state)))

;; Manual save/restore keybindings
(global-set-key (kbd "C-c f w") #'folding-save-state)
(global-set-key (kbd "C-c f r") #'folding-restore-state)
#+end_src

* Additional Conveniences

** Utility Functions
Extra convenience functions for folding management.

#+begin_src emacs-lisp
(defun folding-status ()
  "Show current folding status in minibuffer."
  (interactive)
  (if-let ((cache folding-state-cache))
      (message "Folding: %d/%d active" (car cache) (cdr cache))
    (message "No folding information available")))

(global-set-key (kbd "C-c f i") #'folding-status)

;; Initialize folding state on startup
(add-hook 'emacs-startup-hook
          (lambda ()
            (run-with-idle-timer 2 nil
                                 (lambda ()
                                   (dolist (buf (buffer-list))
                                     (with-current-buffer buf
                                       (when (derived-mode-p 'prog-mode)
                                         (folding-update-state-cache))))))))

(provide 'code-folding)
;;; code-folding.el ends here
#+end_src

* Keybinding Reference

** Hideshow Bindings
| Keybinding | Function           | Description              |
|------------|--------------------|--------------------------|
| =C-c h t=  | hs-toggle-hiding   | Toggle current fold      |
| =C-c h h=  | hs-hide-block      | Hide current block       |
| =C-c h s=  | hs-show-block      | Show current block       |
| =C-c h H=  | hs-hide-all        | Hide all blocks          |
| =C-c h S=  | hs-show-all        | Show all blocks          |

** Treesit-fold Bindings
| Keybinding | Function              | Description              |
|------------|-----------------------|--------------------------|
| =C-c f t=  | treesit-fold-toggle   | Toggle current fold      |
| =C-c f h=  | treesit-fold-close    | Close current fold       |
| =C-c f s=  | treesit-fold-open     | Open current fold        |
| =C-c f H=  | treesit-fold-close-all| Close all folds          |
| =C-c f S=  | treesit-fold-open-all | Open all folds           |

** Unified Interface
| Keybinding   | Function              | Description              |
|--------------|-----------------------|--------------------------|
| =C-c TAB=    | unified-fold-toggle   | Smart fold toggle        |
| =C-c C-h=    | unified-fold-hide-all | Smart hide all           |
| =C-c C-s=    | unified-fold-show-all | Smart show all           |

** Additional Functions
| Keybinding | Function                 | Description                    |
|------------|--------------------------|--------------------------------|
| =C-c e f=  | lsp-apply-folding-ranges | Apply LSP folding ranges       |
| =C-c m f=  | toggle-folding-modeline  | Toggle folding modeline        |
| =C-c f w=  | folding-save-state       | Save folding state             |
| =C-c f r=  | folding-restore-state    | Restore folding state          |
| =C-c f i=  | folding-status           | Show folding info              |

* Installation and Usage

** Installation
1. Save this configuration to a file (e.g., =code-folding.org=)
2. Tangle the code blocks to generate =code-folding.el=:
   #+begin_example
   M-x org-babel-tangle
   #+end_example
3. Add to your Emacs configuration:
   #+begin_src emacs-lisp :tangle no
   (load-file "path/to/code-folding.el")
   #+end_src

** Requirements
- Emacs 29+ (for tree-sitter support)
- =treesit-fold= package
- =doom-modeline= (optional, for modeline integration)
- =eglot= (for LSP folding support)

** Quick Start
After installation, folding will be automatically enabled in programming modes:
- Use =C-c TAB= to toggle folds
- Use =C-c C-h= to hide all folds
- Use =C-c C-s= to show all folds
- Folding states will persist across sessions automatically
